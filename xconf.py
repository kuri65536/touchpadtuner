#! env python
# -= encoding=utf-8 =-
'''
Copyright (c) 2018, 2017, shimoda as kuri65536 _dot_ hot mail _dot_ com
                    ( email address: convert _dot_ to . and joint string )

This Source Code Form is subject to the terms of the Mozilla Public License,
v.2.0. If a copy of the MPL was not distributed with this file,
You can obtain one at https://mozilla.org/MPL/2.0/.
'''
from __future__ import print_function
# from logging import info

import common
from xprops import NProp, NPropDb

try:
    from typing import (Any, Callable, Dict, IO, List, Optional,
                        Text, Tuple, Union, )
    Any, Callable, Dict, IO, List, Optional, Text, Tuple, Union
except:
    pass


def allok(seq):
    # type: (List[Text]) -> bool
    return True


class XSectionSynaptics(object):  # {{{1
    def __init__(self):
        # type: () -> None
        self.f_synaptics = False
        self.f_touchpad = False
        self.f_devicepath = False
        self.f_bcm5974 = False

    @classmethod  # is: Identifier "something" {{{1
    def is_identifier(self, line):
        # type: (Text) -> Text
        line = line.strip().lower()
        if not line.startswith("identifier"):
            return ""
        seq = line.split('"')
        ret = seq[1]
        return ret

    @classmethod  # is: Driver "synaptics"  {{{1
    def is_driver_synaptics(self, line):
        # type: (Text) -> bool
        line = line.strip().lower()
        if not line.startswith('driver '):
            return False
        line = line[7:].strip()
        if not line.startswith('"synaptics"'):
            return False
        return True

    @classmethod  # is: MatchIsTouchpad "on"  {{{1
    def is_touchpad(self, line):
        # type: (Text) -> bool
        line = line.strip().lower()
        if not line.startswith('matchistouchpad '):
            return False
        line = line[16:].strip()
        if not line.startswith('"on"'):
            return False
        return True

    @classmethod  # is: MatchProduct "bcm5974"  {{{1
    def is_match_product_bcm5974(cls, line):
        # type: (Text) -> bool
        line = line.strip().lower()
        if not line.startswith('matchproduct '):
            return False
        line = line[13:].strip()
        if "bcm5974" not in line:
            return False
        return True

    @property  # is_enabled {{{1
    def is_enabled(self):
        # type: () -> bool
        return all([self.f_synaptics, self.f_touchpad,
                    not self.f_bcm5974])

    def parse_line(self, line):  # {{{1
        # type: (Text) -> None
        if (not self.f_bcm5974 and
                self.is_match_product_bcm5974(line)):
            self.f_bcm5974 = True
            return
        if (not self.f_synaptics and
                self.is_driver_synaptics(line)):
            self.f_synaptics = True
            return
        if (not self.f_touchpad and
                self.is_touchpad(line)):
            self.f_touchpad = True
            return


class XConfFile(object):  # {{{1
    # {{{1
    def __init__(self):  # {{{1
        # type: () -> None
        self.section_parser_clear()

    def section_parser_clear(self):  # {{{1
        # type: () -> None
        self.f_section = False
        self.f_endofsection = False
        self.n_section = 0
        self.cur_section = ""
        self.sections = {}  # type: Dict[Text, int]

    def read(self, fname):  # {{{1
        # type: (str) -> NPropDb
        ret = NPropDb()
        fp = common.open_file(fname, "r")
        self.section_parser_clear()
        flagsSyn = XSectionSynaptics()
        lines = []  # type: List[Text]
        for i, line in enumerate(fp):
            sec = self.section_parser(line)
            if not self.f_section:
                continue
            lines.append(line)
            if sec >= 0:
                flagsSyn.parse_line(line)
                continue
            buf, flags = lines, flagsSyn
            lines, flagsSyn = [], XSectionSynaptics()
            if not flags.is_enabled:
                continue
            for line in buf:
                prop = NProp.parse(line)
                if prop is None:
                    continue  # just ignore that line could not be parsed.
                ret.put(self.cur_section, prop)
        fp.close()
        return ret

    def save(self, fname, fnameIn, db):  # {{{1
        # type: (Text, Text, NPropDb) -> bool
        '''sample output {{{3
            # Example xorg.conf.d snippet that assigns the touchpad driver
            # to all touchpads. See xorg.conf.d(5) for more information on
            # InputClass.
            # DO NOT EDIT THIS FILE, your distribution will likely overwrite
            # it when updating. Copy (and rename) this file into
            # /etc/X11/xorg.conf.d first.
            # Additional options may be added in the form of
            #   Option "OptionName" "value"
            #
            Section "InputClass"
                    Identifier "touchpad catchall"
                    Driver "synaptics"
                    MatchIsTouchpad "on"
                    Option "TapButton3" "2"
                    Option "FingerLow" "50"
                    Option "FingerHigh" "100"
                    Option "VertTwoFingerScroll" "on"
                    Option "HorizTwoFingerScroll" "on"
            # This option is recommend on all Linux systems using evdev,
            # but cannot be
            # enabled by default. See the following link for details:
            # http://who-t.blogspot.com/2010/11/
            #                           how-to-ignore-configuration-errors.html
                  MatchDevicePath "/dev/input/event*"
            EndSection

            # This option enables the bottom right corner to be a right button
            # on clickpads
            # and the right and middle top areas to be right / middle buttons
            # on clickpads
            # with a top button area.
            # This option is only interpreted by clickpads.
            Section "InputClass"
                    Identifier "Default clickpad buttons"
                    MatchDriver "synaptics"
                    Option "SoftButtonAreas" "50% 0 82% 0 0 0 0 0"
                    Option "SecondarySoftButtonAreas"
                        "58% 0 0 15% 42% 58% 0 15%"
            EndSection  # }}}
        '''
        fp = common.open_file(fname, "w")
        fi = common.open_file(fnameIn, "r")
        buf = []  # type: List[Text]
        self.section_parser_clear()
        flagsSyn = XSectionSynaptics()
        for i, line in enumerate(fi):
            n_sec = self.section_parser(line)
            if not self.f_section:
                fp.write(line)
                continue
            buf.append(line)
            if n_sec > 0:
                flagsSyn.parse_line(line)
                continue
            if flagsSyn.is_enabled:
                # leave section -> parse buffer!
                self.parse_section(fp, db, buf)
            else:
                for s in buf:
                    fp.write(s)
            buf = []
            flagsSyn = XSectionSynaptics()
            self.cur_section = ""
        # did not close section...
        fi.close()
        fp.close()
        return False

    def is_begin_of_section(self, line):  # {{{2
        # type: (Text) -> Text
        line = line.strip().lower()
        if not line.startswith('section '):
            return ""
        seq = line.split('"')
        ret = seq[1]
        return ret

    def is_end_section(self, line):  # {{{2
        # type: (Text) -> bool
        line = line.strip().lower()
        return line.startswith("endsection")

    def section_parser(self, line):  # {{{1
        # type: (Text) -> int
        if self.f_endofsection:
            self.f_section = self.f_endofsection = False
            return -1
        if self.is_end_section(line):
            self.f_endofsection = True
            return -1
        if not self.f_section:
            # secname is lower-case
            secname = self.is_begin_of_section(line)
            if secname == "":
                return -1
            if secname != "inputclass":
                return -1
            self.n_section += 1
            self.f_section = True
            return self.n_section
        if self.cur_section == "":
            id_name = XSectionSynaptics.is_identifier(line)
            if id_name != "":
                self.cur_section = id_name
                self.sections[id_name] = self.n_section
                return self.n_section
        return self.n_section

    def save_remains(self, fp, db, sec):  # {{{2
        # type: (IO[Text], NPropDb, Text) -> bool
        fWrote = False
        for n, prop in db.items(sec):
            if not isinstance(prop, NProp):
                continue
            # TODO(shimoda): implement
            if True:
                """
            for idx, fmt in enumerate(prop.format_with_value()):
                if fmt.is_ is None:
                    continue  # not specified clearly
                if idx in prop.wrote:
                    continue  # already output
                if v == -1:
                    continue  # not specified output
                # TODO(Shimoda): check v is default
                # if is_default(v):
                #    continue
                """
                if not fWrote:
                    fWrote = True
                    fp.write(" " * 8 + "# output by touchpadtuner\n")
                """
                line = prop.compose(idx)
                fp.write(line)
            """
        return False

    def parse_section(self, fp, db, buf):  # {{{1
        # type: (IO[Text], NPropDb, List[Text]) -> bool
        sec = self.cur_section
        for line in buf[:-1]:
            prop = NProp.parse(line)
            if prop is None:
                fp.write(line)
                continue
            try:
                cur = db.get(sec, prop)
                if prop.same_prop(cur):
                    fp.write(line)
                    continue
                line = prop.compose_all()
                fp.write(line)
            except KeyError:
                pass
        self.save_remains(fp, db, sec)
        fp.write(buf[-1])

        """
        # ret += self.dump_line_int("FingerLow", db.fingerlow())
        # ret += self.dump_line_int("FingerHigh", db.fingerhig())
        # ret += self.dump_line_bool("VertTwoFingerScroll",
        #                            db.vert2fingerscroll())
        # ret += self.dump_line_bool("HorizTwoFingerScroll",
        #                            db.horz2fingerscroll())
        return False

        """
        return False


# main {{{1
def main():  # {{{1
    # type: () -> int
    pass  # TODO: launch test


if __name__ == "__main__":  # end of file {{{1
    main()
# vi: ft=python:et:fdm=marker:nowrap:tw=80
